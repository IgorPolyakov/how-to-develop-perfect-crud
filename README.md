# Backend Test Task Right Way
# Что это?
Данная статья рассказывает о наборе правил которые полезно знать и применять при разработке бэкэнда для тестового задания (Чтобы максимизировать свои шансы на оффер или собеседование).
# Здесь только про Backend? 
Так как автор имеет экспертизу только в бэкэнде то и большая часть советов будет относиться к разработке бэкэнд приложений. В прочем многие из советов будут полезны и для других специальностей.

# Содержание
## Репозиторий
* Код должен храниться в публичном/приватном Git репозитории (Github / Gitlab / Bitbucket)
* README должен содержать информацию о проекте, инструменты и технологии, инструкцию по настройке и запуску приложения
* Должен быть настроен Continuous Integration (Gitlab CI / Github Actions)
* Будет огромным плюсом если будет настроен Continuous Delivery (раньше можно было по кнопке деплоить на хероку)
* Осмысленная история коммитов + использование feature branches, pull requests + 
* Необязательно: настроенный [dependabot](https://docs.github.com/ru/code-security/dependabot/working-with-dependabot)
## Стайлгайд
Перед разработкой приложения:
* Настрой редактор или IDE которая интегрируется с выбранными тобой инструментами по форматированию кода (VS Code, Visual Studio, PyCharm, etc)
* Установи EditorConfig плагин для твоего редактора, заполни его конфигурацией согласно best practices (ну или просто погугли editorconfig &lt;language name> config)
* Установи и настрой наиболее популярные и общепринятые инструменты по верификации качества кода для твоего языка (rubocop for ruby, pylint/black/pep8 for python). 
* Интегрируй прогон линтера в CI для каждой фича ветки и мастер ветки.
* Задача со звездочкой: Интегрировать библиотеку которая будет находить уязвимости в коде или детектить небезопасные версии библиотек (аля bundler-audit for ruby)
## Тесты
* Установи весь необходимый набор библиотек для написания тестов различных видов (unit, integration). Например:
   * Pytest for Python
   * RSpec for Ruby
   * Testify for Golang
* Интегрируй сбор покрытия тестами (test coverage) и следи за его состоянием (чтобы понимать какой код не протестирован)
* Интегрируй прогон тестов  в CI для каждой фича ветки и мастер ветки
## Инфраструктура вокруг кода
Прежде всего: установи docker + docker-compose
### Приложение как Docker container
- Заверните свое приложение в Docker Container ([как это делать правильно](https://cloud.google.com/architecture/best-practices-for-building-containers)
### Внешние зависимости
- Опиши все зависимости своего приложения (PostgreSQL, S3, Redis etc) как Docker контейнеры.
- Настройка приложения и запуск должны делаться максимально просто и прозрачно (желательно в 1 команду)
### Конфигурация
* Настройте application сервер для production сборки приложения:
   * Puma for Ruby
   * Gunicorn3 for Python
   * Undertow for Java
* При описании конфигурации приложения используется https://12factor.net

## Разработка
Обычно тестовые задания подразумевают собой некий CRUD + какой нибудь эндпоинт который требует от кандидата написать SQL запрос с фильтром и группировкой. 

Поэтому рассмотрим типичные полезности при разработке типичного CRUD API


### API

* API должен быть описан по [REST](https://www.freecodecamp.org/news/rest-api-best-practices-rest-endpoint-design-examples/) (если не требуется иначе) 
* Должна быть настроена [Swagger](https://swagger.io/) спецификация которую можно открыть в браузере
* Формат данных: JSON (если не требуется другого)
Дополнительно:
- убедиться что реализованное API идемпотентно: [https://habr.com/ru/company/yandex/blog/442762/](https://habr.com/ru/company/yandex/blog/442762/)
- подключить Rate Limiter для API

### Распределение логики в коде (MVC)

Важно показать в коде что вы умеете делить обязанности и логику между компонентами. Ниже разобрана логика разделения ответственности на примере MVC паттерна. Вы можете использовать любой другой паттерн (особенно если ваш фреймоврк не предоставляет MVC сущности из коробки) но всегда помните про первый принцип SOLID и разделяйте ответственности.
#### Controller
- Принимает тело запроса, валидирует его на соответствие API
- Проверяет authorization + authentification 
- Вызывает Service, передает ему данные
- На основе возвращаемого значения от Service вызывает код формирующий нужный ответ API (через View)


#### Model
* Хранит только описание схемы данных и связи с другими моделями
* Бизнес логики хранит по минимуму а лучше не хранит вообще
* Используется для того чтобы делать запросы к БД на чтение и запись
#### Service
* Принимает данные от контроллера, валидирует тело, проверяет права доступа (авторизацию, аутентификацию)
* Использует Model для чтения или записи данных в БД.
* Отвечает за бизнес-логику приложения
#### View
* Отвечает за то чтобы на основе данных сформировать API ответ.
### Авторизация и аутентификация
API должно быть защищено (условно, нельзя опубликовать пост или коммент если ты не авторизован)

В качестве аутентификации по API можно использовать:
* Basic Auth (простой путь)
* JWT (посложнее)

Также важно реализовать авторизацию (означает доступ к ресурсу для пользователя). 
Например: пользователь которого забанил администратор не может публиковать комменты (хотя он прошел аутентификацию на сайте). При попытке вызвать API он должен получить ошибку Forbidden


### CRUD: Step 1. Валидация данных
Перед тем как сохранять данные в БД обязательно:
- отвалидируйте данные на тип (там где ожидается строка пришла строка, где int там int итп)
- и соответствие тела запроса API (если пользователь отправил поля которые не имеет права отпралять в БД мы должны их игнорировать)
### CRUD: Step 2. Database
* Всегда используйте ORM (это проще и безопаснее) если в задании не указано что нужно писать чистый SQL
* Используйте механизм миграций чтобы создавать таблицы и другие сущности в вашей БД (Rails Migrations, Flask-Migrate, etc)
* При описании таблиц важно сразу указать всем столбцам необходимые constraints (NULLABLE, DEFAULT VALUE, UNIQUE, PRIMARY KEY)
* При описании таблиц важно сразу указать индексы для столбцов по которым ожидается поиск.

P.S. При описании миграций полезно подсматривать [сюда](https://github.com/ankane/strong_migrations), чтобы не написать миграцию которая может заблокировать БД.
### CRUD: Step 3. Operations
#### LIST



* Не возвращай все поля модели, это может быть избыточно, например если просят список постов то возвращай только ID, название и ник автора, сам текст поста не нужен.
* Всегда возвращай их отсортированными по какому либо признаку, например по времени.
* Не забудь добавить пагинацию для всех эндпоинтов отдающих больше 1 сущности. Виды пагинаций хорошо рассмотрены тут ([https://dev.to/appwrite/this-is-why-you-should-use-cursor-pagination-4nh5](https://dev.to/appwrite/this-is-why-you-should-use-cursor-pagination-4nh5))
* Для каждого ресурса в ответе должен быть ID 
* Проверь что на этом запросе нет N+1 проблемы


#### READ



* Возвращаем полностью ресурс со всеми полями, ничего особенного


#### CREATE



* Валидируем, отправляем в БД, возвращаем в ответ ID и содержимое. Валидировать ввод на предмет полей которые пользователь не имеет права изменять в БД а следовательно передавать.


#### UPDATE



* Разобраться в чем отличие между PUT и PATCH в HTTP
* реализовать обновление согласно выбранному методу
* Валидировать ввод на предмет полей которые пользователь не имеет права изменять в БД а следовательно передавать.


#### DESTROY



* Реализовать удаление предварительно проверив наличие сущности в БД
* Задание со звездочкой: реализовать soft удаление через метку


### Взаимодействие с внешними сервисами, трудоемкие операции

Если вас в задании просят чтобы вы делали в рамках своего API запросы к внешним системам то первое что о чем нужно подумать



* Можно ли это делать в отложенном режиме (тогда стоит завести очередь задач под это дело)
* Работу с ошибками: что делать если API ответит огибкой? А если оно недоступно?


### Метрики, Логи



* Если вы настроите стандартный набор prometheus метрик для вашего приложения используя какую нибудь готовую либу это только добавит вам баллов и проверяющий почти наверняка скажет “надо брать”
