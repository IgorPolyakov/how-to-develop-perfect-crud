# Backend Test Task Right Way
# Что это?
Данная статья рассказывает о наборе правил которые полезно знать и применять при разработке бэкэнда для тестового задания (Чтобы максимизировать свои шансы на оффер или собеседование).
# Здесь только про Backend? 
Так как автор имеет экспертизу только в бэкэнде то и большая часть советов будет относиться к разработке бэкэнд приложений. В прочем многие из советов будут полезны и для других специальностей.

# Содержание

## Репозиторий



1. Код должен храниться в публичном репозитории (Github / Gitlab / Bitbucket)
2. README должен содержать информацию о проекте, инструменты и технологии, инструкцию по настройке и запуску приложения
3. Должен быть настроен CI (линтер, тесты)
4. Будет огромным плюсом если будет настроен CD (раньше можно было по кнопке деплоить на хероку)
5. Осмысленная история коммитов + использование фича бранчей и пулл реквестов и МРов
6. dependabot полезно иметь настроенным


## Стайлгайд



* Используй редактор или IDE которая интегрируется с выбранными тобой инструментами по форматированию кода (VS Code, Visual Studio, PyCharm, etc)
* Установи EditorConfig плагин для твоего редактора, заполни его конфигурацией согласно best practices (ну или просто погугли editorconfig &lt;language name> config)
* Установи и настрой наиболее популярные и общепринятые инструменты по верификации качества кода для твоего языка (rubocop for ruby, pylint/black/pep8 for python). Желательно это сделать до начала написания кода
* Интегрируй прогон линтера в CI для каждой фича ветки и мастер ветки.
* Задача со звездочкой: Интегрировать библиотеку которая будет находить уязвимости в коде или детектить небезопасные версии библиотек (аля bundler-audit for ruby)


## Тесты



* Установи весь необходимый набор библиотек для написания тестов (unit, integration). Например: Pytest for Python, RSpec for Ruby, Testify for Golang.
* Для интеграционных тестов убедись что правильно настроил очистку тестовой БД перед каждым тестом.
* Интегрируй сбор покрытия тестами (test coverage) и следи за его состоянием (чтобы понимать какой код не протестирован)
* Интегрируй прогон тестов  в CI для каждой фича ветки и мастер ветки


## Инфраструктура вокруг кода



* Любые зависимости твоего приложения (PostgreSQL, S3, Redis etc) лучше всего иметь как docker контейнеры. Установи docker + docker-compose и сделай так чтобы настройка запуск всей инфры занимала одну команду в терминале (максимум 2). Будет легче самому в процессе разработки + проверяющий оценит желание и умение автоматизировать.


## Конфигурация



* Используй 12 factor manifesto для проброса конфигурации в приложение
* используйте специальный application сервер для production сборки приложения (puma for ruby, python for rails, undertow for ja va)


## Разработка

Обычно тестовые задания подразумевают собой некий CRUD + какой нибудь эндпоинт который требует от кандидата написать SQL запрос с фильтром и группировкой. Поэтому рассмотрим типичные полезности при разработке типичного CRUD API


### API



* Используйте REST нотацию при описании ендпоинтов https://www.freecodecamp.org/news/rest-api-best-practices-rest-endpoint-design-examples/
* Используй OPEN API / Swagger для описания API (либо настрой автогенерацию на основе кода, такое тоже есть) - по сути это и будет докой к проекту

Задание со звездочкой - убедиться что реализованное API Идемпотентно: [https://habr.com/ru/company/yandex/blog/442762/](https://habr.com/ru/company/yandex/blog/442762/)

Задание со звездочкой №2 - подключить Rate Limiter для API


### Валидация данных



* Перед тем как передавать данные в БД или еще куда либо обязательно отвалидируйте данные на формат и соответствие схеме данных


### БД



* Всегда используйте ORM (это проще и безопаснее) если в задании не указано что нужно писать чистый SQL
* Используйте механизм миграций чтобы создавать таблицы и другие сущности в вашей БД (rails migrations, flask-migrate, etc)


### Распределение логики в коде (по MVC)

Важно показать в коде что вы умеете делить обязанности и логику между компонентами. Ниже разобрана логика разделения ответственности на примере MVC паттерна. Вы можете использовать любой другой паттерн (особенно если ваш фреймоврк не предоставляет MVC сущности из коробки) но всегда помните про первый принцип SOLID и разделяйте ответственность.


#### Controller



* должен быть максимально тонким, в его обязанности входит
    * Вызов кода который валидирует HTTP request
    * Вызов кода который превращает raw json в какую либо типизированную структуру
    * Вызов кода совершающего бизнес действие
    * Отдать ответ клиенту (в том числе неуспешный если один из пунктов выше пошел не по плану)


#### Model



* Хранит только описание схемы данных и связи с другими моделями
* Бизнес логики хранит по минимуму а лучше не хранит вообще


#### View



* Отвечает за то чтобы на основе данных из Controller сгенерировать ответ для client


#### Service



* Принимает данные от контроллера, валидирует тело, проверяет права доступа (авторизацию, аутентификацию)
* Взаимодействует с моделью


### Авторизация и аутентификация

В задании тебя могут попросить реализовать авторизацию и регистрацию для пользователей. 

В качестве аутентификации по API можно использовать например



* Basic Auth (простой путь)
* JWT (посложнее)

Твое API должно быть защищено (условно, нельзя опубликовать пост или коммент если ты не авторизован)

Также важно пробовать авторизацию (означает доступ к ресурсу для пользователя). 

Например, если API делится на публичное и админское (закрытое) то при попытке обычным пользователем вызвать такой метод должен произойти ошибка - нет доступа)


### Операции


#### LIST



* Не возвращай все поля модели, это может быть избыточно, например если просят список постов то возвращай только ID, название и ник автора, сам текст поста не нужен.
* Всегда возвращай их отсортированными по какому либо признаку, например по времени.
* Не забудь добавить пагинацию для всех эндпоинтов отдающих больше 1 сущности. Виды пагинаций хорошо рассмотрены тут ([https://dev.to/appwrite/this-is-why-you-should-use-cursor-pagination-4nh5](https://dev.to/appwrite/this-is-why-you-should-use-cursor-pagination-4nh5))
* Для каждого ресурса в ответе должен быть ID 
* Проверь что на этом запросе нет N+1 проблемы


#### READ



* Возвращаем полностью ресурс со всеми полями, ничего особенного


#### CREATE



* Валидируем, отправляем в БД, возвращаем в ответ ID и содержимое. Валидировать ввод на предмет полей которые пользователь не имеет права изменять в БД а следовательно передавать.


#### UPDATE



* Разобраться в чем отличие между PUT и PATCH в HTTP
* реализовать обновление согласно выбранному методу
* Валидировать ввод на предмет полей которые пользователь не имеет права изменять в БД а следовательно передавать.


#### DESTROY



* Реализовать удаление предварительно проверив наличие сущности в БД
* Задание со звездочкой: реализовать soft удаление через метку


### Взаимодействие с внешними сервисами, трудоемкие операции

Если вас в задании просят чтобы вы делали в рамках своего API запросы к внешним системам то первое что о чем нужно подумать



* Можно ли это делать в отложенном режиме (тогда стоит завести очередь задач под это дело)
* Работу с ошибками: что делать если API ответит огибкой? А если оно недоступно?


### Метрики, Логи



* Если вы настроите стандартный набор prometheus метрик для вашего приложения используя какую нибудь готовую либу это только добавит вам баллов и проверяющий почти наверняка скажет “надо брать”
